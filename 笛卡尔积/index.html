<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>笛卡尔积 - ZGF Wiki</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u7b1b\u5361\u5c14\u79ef";
    var mkdocs_page_input_path = "\u7b1b\u5361\u5c14\u79ef.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> ZGF Wiki</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../c%2B%2B/">C++</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../python/">Python</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../ubuntu18/">Ubuntu18</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../Ros/">Ros</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../Ros%E5%BB%BA%E6%A8%A1/">Ros建模</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../tf_document/">tf_document</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../caffe/">Caffe</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../deeplearning/">deeplearning</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../voxelnet/">voxelnet</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../radar_camera_fusion/">radar_camera</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../python%E6%9C%89%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0/">python有用的函数(一)</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">ZGF Wiki</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>笛卡尔积</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>${X_i|i\in I}$</p>
<p>
<script type="math/tex; mode=display">
\prod_{x\in I}X_i=\{f:I\rightarrow\bigcup_{x\in I}X_i|(\forall_i)(f(i)\in X_i)\}
</script>
<script type="math/tex; mode=display">
\pi_j(f)=f(j)
</script>
</p>
<p>第j投影映射</p>
<p>$$
\pi_j:\prod_{i\in I}X_i\rightarrow X_j</p>
<p>$$</p>
<p>$$
\prod_{n=1}^{\infty}\mathbb{R}=\mathbb{R}^{\omega}=\mathbb{R}\times\mathbb{R}\cdots</p>
<p>$$</p>
<p>极大似然估计应用于线性回归</p>
<p>极大似然法是一种用于估计模型参数的统计方法。</p>
<p>在最大似然估计中，选择参数以使假设的模型产生观测数据的可能性最大。</p>
<ol>
<li>假设我们有个模型，也称为数据生成过程。</li>
<li>能够为我们的数据导出似然函数。</li>
</ol>
<p>一旦导出似然函数，最大似然估计仅是一个简单的优化问题。</p>
<p>极大似然估计的优势：</p>
<ul>
<li>如果正确设定了模型，最大似然估计器将是最有效的估计器</li>
<li>它提供了一致但灵活的方法，使其适用于各种应用程序，包括其他设定模型无效的情况。</li>
<li>在较大模型中得出无偏估计</li>
</ul>
<p>效率是估计器质量的一种度量，有效的估计器具有较小的方差或均方误差。</p>
<p>极大似然估计的缺点：</p>
<ul>
<li>它依赖于模型的设定以及似然函数的推导，而这种推导并不总是那么容易</li>
<li>像其他优化问题一样，最大 似然估计可能对初始值的选择很敏感。</li>
<li>取决于似然函数的复杂度，数值估计在计算上可能是昂贵的。</li>
<li>小样本的估计值可能有偏差。</li>
</ul>
<p>极大似然估计取决于似然函数的推导。因此重要的是要对似然函数是什么以及它来自何处有一个很好的了解。</p>
<p>极大似然估计的第一步是假设数据的概率分布，概率密度函数在给定一组基础模型参数的情况下测量观察数据的概率。</p>
<p>我们假设我们的数据具有潜在的泊松分布，这是一个普遍的假设，尤其对于非负计数数据。</p>
<p>单个观测值$y_i$的泊松概率密度函数由下式给出：</p>
<p>$$
f(y_i|\theta)=\frac{e^{-\theta}\theta^{y_i}}{y_i!}</p>
<p>$$</p>
<p>由于我们样本中的观测值是独立的，因此可以通过取各个观测值的概率乘积来求出我们观测样本的 概率密度：</p>
<p>$$
f(y_1,y_2,\cdots,y_{10}|\theta)=\prod_{i=1}^{10}\frac{e^{-\theta}\theta^{y_i}}{y_i!}=\frac{e^{-10\theta}\theta\sum_{i=1}^{10}y_i}{\prod_{i=1}^{10}y_i!}</p>
<p>$$</p>
<p>我们可以使用概率密度来回答在给定特定参数的情况下数据发生的可能性。</p>
<p>似然函数和概率密度函数的不同是细微的但是是重要的</p>
<ul>
<li>概率密度函数强调在给定基础分布参数的情况下观察我们数据的概率，前提是假设参数已知。</li>
<li>似然函数强调观测数据时出现参数值的可能性，这里参数是未知的。</li>
</ul>
<p>数学上似然函数和概率密度函数很像</p>
<p>$$
L(\theta|y_1,y_2,\cdots,y_{10})=f(y_1,y_2,\cdots,y_{10}|\theta)</p>
<p>$$</p>
<p>对于我们的泊松分布数据，我们相当容易的得到似然函数</p>
<p>$$
L(\theta|y_1,y_2,\cdots,y_{10})=\frac{e^{-10\theta}\theta\sum_{i=1}^{10}y_i}{\prod_{i=1}^{10}y_i!}=\frac{e^{-10\theta}\theta^{20}}{207360}</p>
<p>$$</p>
<p>$$
\prod_{k=3}^{7}k=3\times4\times5\times6\times7</p>
<p>$$</p>
<p>未知参数$\theta$的极大似然估计，是使这种可能性最大化的值。</p>
<p><strong>对数似然函数</strong></p>
<p>在实际中，联合分配函数难以使用，一般用$ln$似然函数代替。在我们的泊松数据里对数似然函数是：
<script type="math/tex; mode=display">ln(L(\theta|y)=-n\theta+ln\sum_{i=1}^{n}y_i-ln\theta\sum_{i=1}^{n}y_i!=-10\theta+20ln(\theta)-ln(207360)</script>
</p>
<p>在线性回归，我们假设模型的残差是独特的完全正态分布。
<script type="math/tex; mode=display">\epsilon=y-\hat{\beta}x\quad\sim N(0,\delta^2)</script>
对于这种情况，未知参数向量$\theta={\beta,\delta^2}$,观察数据的条件y和x已知，对数似然函数是：
<script type="math/tex; mode=display">lnL(\theta|y,x)=-\frac{1}{2}\sum_{i=1}^{n}\left[ln\delta^2+ln(2\pi)+\frac{y-\hat{\beta}x}{\delta^2}\right]</script>
$\beta$和$\delta^2$的极大似然估计就是使可能最大化的值。
<strong>极大似然估计和概率模型</strong>
<script type="math/tex; mode=display">y^*=x\theta+\epsilon\quad\epsilon\sim N(0,1)</script>
<script type="math/tex; mode=display">y_i=\left\{\begin{matrix}0\quad if\quad y^{*}_{i}\leqslant0 &\\1\quad if\quad y^{*}_i>0\end{matrix}\right.</script>
<script type="math/tex; mode=display">P(y_i=1|X_i)=P(y^*_i>0|X_i)=P(x\theta+\epsilon>0|X_i)=P(\epsilon>-x\theta|X_i)=1-\Phi(-\theta x)=\Phi(x\theta)</script>
$\Phi$代表正态累计分布。
每个$y_i$是独立的所以
<script type="math/tex; mode=display">f(y=(y_1,y_2,\cdots,y_n|w)=f_1(y_1|w)f_2(y_2|w)\cdots f_n(y_n|w)</script>
<script type="math/tex; mode=display">log\pi_\theta(\alpha|s)=log[P_\theta(s)]_\alpha</script>
<strong>采样</strong>
已知mean action $\mu_\theta(s)$和标准偏差$\delta_\theta(s)$和球形高斯噪音的向量z（$z\sim N(0,1)$）可以计算出一个action sample
<script type="math/tex; mode=display">\alpha=\mu_\theta(s)+\delta_\theta(s)\bigodot z</script>
$\bigodot$代表两个向量元素乘积。</p>
<p>对于均值$\mu=\mu_\theta(s),标准偏差$$\delta=\delta_\theta(s)$的对角高斯，$k$维action $\alpha$ 的对数似然由以下给出：
<script type="math/tex; mode=display">log\pi_\theta(\alpha|s)=-\frac{1}{2}\left(\sum_{i=1}^{k}\left(\frac{(\alpha_i-\mu_i)^2}{\delta^2_i}+2log\delta_i\right)+klog2\pi\right)</script>
<strong>Trajectories</strong>
一个轨迹$\tau$是world里一系列状态和action。
<script type="math/tex; mode=display">\tau=(s_0,\alpha_0,s_1,\alpha_1,\cdots)</script>
<script type="math/tex; mode=display">s_{t+1}=f(s_t,\alpha_t)</script>
Or 
<script type="math/tex; mode=display">s_{t+1}\sim P(\cdot|s_t,\alpha_t)</script>
actions是代理通过策略产生的
<strong>奖励和反馈</strong>
奖励取决于当前world的状态，刚刚采取的action和world的下一个状态
<script type="math/tex; mode=display">r_t=R(s_t,a_t,s_{t+1})</script>
有时会简化为$r_t=R(s_t)$或者state-action $r_t=R(s_t,a_t)$
代理的目标是使某个轨迹上的某个概念的累计奖励最大化。
我们将通过以下方式记录所有的情况$R(\tau)$</p>
<p>一种反馈是有限水平的无折现反馈，就是所有奖励的和
<script type="math/tex; mode=display">R(\tau)=\sum_{t=0}^{T}r_t</script>
另一种反馈是有限水平的折现反馈，代理获得的奖励之和，折现将来代理获得的how far off.这个方程式的奖励包含一个折现因子$\gamma\in(0,1)$
<script type="math/tex; mode=display">R(\tau)=\sum_{t=o}^{\infty}\gamma^t\tau_t</script>
为什么我们想要一个折现的反馈，而不是所有的反馈？我们的确想要所有反馈，但是折现因子在直观上即吸引人，数学实现起来又方便。一种直觉：现在的现金比以后的现金好。数学上：无限水平的奖励之和可能不会收敛到有限的值，并且很难用方程式处理。但是在有折现因子的情况下，并在合理的条件下，无穷大是收敛的。</p>
<p>Deep RL 练习往往会使这条线模糊不清，例如，我们经常设置算法以优化未折现的反馈，但在评价value function 的时候使用折现因子。</p>
<p>无论选择哪种反馈方法，选择哪种策略，RL的目标是选择一个策略使代理运行此策略使期望的反馈最大化。
要讨论期望的反馈，我们先来讨论一下轨迹上的概率分布。</p>
<p>让我假设环境转变和策略都是随机的。在这种情况下，轨迹T-step的概率是：
<script type="math/tex; mode=display">P(T|\pi)=\rho_0(s_0)\prod_{t=0}^{T-1}P(s_{t+1}|s_t,\alpha_t)\pi(s_t,\alpha_t)</script>
期望的反馈表示为
<script type="math/tex; mode=display">J(\pi)=\int_{r}P(\tau|\pi)R(\tau)=\underset{\tau\sim\pi}{E}[R(\tau)]</script>
RL中的集中优化问题可以表示为：
<script type="math/tex; mode=display">\pi^*=arg\quad\underset{\pi}{max}J(\pi)</script>
$\pi^<em>$是最佳策略。
</em><em>Value Function</em><em>
知道value of state 或者 state-action 通常是有用的。
这里有四种value function.
1. 基于策略的value function.$V^\pi(s)$,当state s,执行策略$\pi$时，
<script type="math/tex; mode=display">V^\pi(s)=\underset{\tau\in\pi}{E}[R(\tau)|s_0=s]</script>
2. 基于策略的 action-value function. $Q^\pi(s,\alpha)$,
<script type="math/tex; mode=display">Q^\pi(s,\alpha)=\underset{\tau\in\pi}{E}[R(\tau)|s_0=s,a_0=a]</script>
3. 最优value function， $V^</em>(s)$
<script type="math/tex; mode=display">V^*(s)=\underset{\pi}{max}\underset{\tau\in\pi}{E}[R(\tau)|s_0=s]</script>
4. 最佳action-value function, $Q^*(s,\alpha)$</p>
<p>
<script type="math/tex; mode=display">Q^*(s,\alpha)=\underset{\pi}{max}\underset{\tau\in\pi}{E}[R(\tau)|s_0=s,\alpha_0=\alpha]</script>
在value function 和 action-value function 之间有两个关键的链接
<script type="math/tex; mode=display">V^\pi(s)=\underset{\alpha\sim\pi}{E}[Q^\pi(s,\alpha)]</script>
和
<script type="math/tex; mode=display">V^*(s)=\underset{\alpha}{max}Q^*(s,\alpha)</script>
<script type="math/tex; mode=display">\alpha^*(s)=arg\quad\underset{\alpha}{max}Q^*(s,\alpha)</script>
<strong>贝尔曼方程</strong>
这4个value function都遵循的特殊自治方程,称为Bellman equations
Bellman equation后面的基本思想是：
    起点处的value，是你期望从那里得到的reward，再加上下一步到达地方的value。</p>
<p>基于策略的value function 的Bellman equations
<script type="math/tex; mode=display">V^\pi(s)=\underset{s'\sim P}{\underset{\alpha\sim\pi}{E}}[\tau(s,\alpha)+\gamma V^\pi(s')]</script>
<script type="math/tex; mode=display">Q^\pi(s,\alpha)=\underset{s'\sim P}{E}\left[\tau(s,\alpha)+\gamma\underset{a'\sim\pi}{E}[Q^\pi(s',\alpha')]\right]</script>
$s'\sim P$是$s'\sim P(\cdot|s,\alpha)$的缩写，指示下一状态$s'$从环境的过度规则中采样；$\alpha\sim\pi$是$\alpha\sim\pi(\cdot|s)$的缩写；$\alpha'\sim\pi$是$\alpha'\sim\pi(\cdot|s')$的缩写。</p>
<p>最佳value function的Bellman equation是
<script type="math/tex; mode=display">V^*(s)=\underset{\alpha}{max}\quad\underset{s'\sim P}{E}[\tau(s,\alpha)+\gamma V^*(s')]</script>
<script type="math/tex; mode=display">Q^*(s,\alpha)=\underset{s'\sim P}{E}\left[\tau(s,\alpha)+\gamma\underset{\alpha'}{max}Q^*(s',\alpha')\right]</script>
Bellman equation:  reward-plus-next-value</p>
<p><strong>Advantage Functions</strong>
<script type="math/tex; mode=display">A^\pi(s,\alpha)=Q^\pi(s,\alpha)-V^\pi(s)</script>
<strong>Markov Decision Processes</strong>
An MDP is a 5-tuple,$(S,A,R,P,\rho_0)$
S is the set of all valid states.
A is the set of all valid actions.
R:$S\times A\times S\rightarrow \mathbb{R}$ is the reward function , with $\tau_t=R(s_t,\alpha_t,s_{t+1})$
P:$S\times A \rightarrow P(S)$ is the transition probability function, with $P(s'|s,\alpha)$ being the probability of transitioning into state $s'$,if you start in state s and take action $\alpha$
$\rho_0$ is the starting state distribution.</p>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../mathjaxhelper.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
