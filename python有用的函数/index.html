<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Python有用的函数 - ZGF Wiki</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Python\u6709\u7528\u7684\u51fd\u6570";
    var mkdocs_page_input_path = "python\u6709\u7528\u7684\u51fd\u6570.md";
    var mkdocs_page_url = "/python\u6709\u7528\u7684\u51fd\u6570/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> ZGF Wiki</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Atlas200验收报告/">Atlas200验收报告</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Autoware.auto/">Autoware.auto</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../OpenCV/">OpenCV</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../PCL/">PCL</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../PPO/">PPO</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Qt/">Qt</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../README/">README</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../RL/">RL</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../ROS2/">ROS2</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Ros/">Ros</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Ros建模/">Ros建模</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../agx/">Agx</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../arm_docker/">Arm docker</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../c++/">C++</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../caffe/">Caffe</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../cmake/">Cmake</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../cuda/">Cuda</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../deeplearning/">Deeplearning</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../deeplearning_work_station/">Deeplearning work station</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../github网页不显示图片/">Github网页不显示图片</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../jekyll/">Jekyll</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../lidar_demo教程/">Lidar demo教程</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../make/">Make</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../python/">Python</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Python有用的函数</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#python">python 有用的函数（一）</a></li>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../pytorch/">Pytorch</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../radar_camera_fusion/">Radar camera fusion</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../ros openai/">Ros openai</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../tf_document/">Tf document</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../ubuntu18/">Ubuntu18</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../ubuntu20/">Ubuntu20</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../util_wiki/">Util wiki</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../vision360/">Vision360</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../voxelnet/">Voxelnet</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../摄像机和毫米波坐标系关系/">摄像机和毫米波坐标系关系</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../毫米波和摄像机融合/">毫米波和摄像机融合</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../激光雷达算法盒子/">激光雷达算法盒子</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../笛卡尔积/">笛卡尔积</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">ZGF Wiki</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Python有用的函数</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="python">python 有用的函数（一）</h1>
<pre><code class="language-python">&quot;&quot;&quot;
 Adapt from fangchangma/sparse_to_dense.pytorch on github
&quot;&quot;&quot;
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import

import torch
import torchvision
import math
import random

from PIL import Image, ImageOps, ImageEnhance
try:
    import accimage
except ImportError:
    accimage = None

import numpy as np
import numbers
import types
import collections

import scipy.ndimage.interpolation as itpl
import scipy.misc as misc


# Check whether the input is a numpy array
def _is_numpy_image(img):
    return isinstance(img, np.ndarray) and (img.ndim in {2, 3})


# Check whether the input is a PIL image
def _is_pil_image(img):
    if accimage is not None:
        return isinstance(img, (Image.Image, accimage.Image))
    else:
        return isinstance(img, Image.Image)


# Check wheter the input is a tensor
def _is_tensor_image(img):
    return torch.is_tensor(img) and img.ndimension() == 3


def adjust_brightness(img, brightness_factor):
    &quot;&quot;&quot;Adjust brightness of an Image.
    Args:
        img (PIL Image): PIL Image to be adjusted.
        brightness_factor (float):  How much to adjust the brightness. Can be
            any non negative number. 0 gives a black image, 1 gives the
            original image while 2 increases the brightness by a factor of 2.
    Returns:
        PIL Image: Brightness adjusted image.
    &quot;&quot;&quot;
    if not _is_pil_image(img):
        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))

    enhancer = ImageEnhance.Brightness(img)
    img = enhancer.enhance(brightness_factor)
    return img


def adjust_contrast(img, contrast_factor):
    &quot;&quot;&quot;Adjust contrast of an Image.
    Args:
        img (PIL Image): PIL Image to be adjusted.
        contrast_factor (float): How much to adjust the contrast. Can be any
            non negative number. 0 gives a solid gray image, 1 gives the
            original image while 2 increases the contrast by a factor of 2.
    Returns:
        PIL Image: Contrast adjusted image.
    &quot;&quot;&quot;
    if not _is_pil_image(img):
        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))

    enhancer = ImageEnhance.Contrast(img)
    img = enhancer.enhance(contrast_factor)
    return img


def adjust_saturation(img, saturation_factor):
    &quot;&quot;&quot;Adjust color saturation of an image.
    Args:
        img (PIL Image): PIL Image to be adjusted.
        saturation_factor (float):  How much to adjust the saturation. 0 will
            give a black and white image, 1 will give the original image while
            2 will enhance the saturation by a factor of 2.
    Returns:
        PIL Image: Saturation adjusted image.
    &quot;&quot;&quot;
    if not _is_pil_image(img):
        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))

    enhancer = ImageEnhance.Color(img)
    img = enhancer.enhance(saturation_factor)
    return img


def adjust_hue(img, hue_factor):
    &quot;&quot;&quot;Adjust hue of an image.
    The image hue is adjusted by converting the image to HSV and
    cyclically shifting the intensities in the hue channel (H).
    The image is then converted back to original image mode.
    `hue_factor` is the amount of shift in H channel and must be in the
    interval `[-0.5, 0.5]`.
    See https://en.wikipedia.org/wiki/Hue for more details on Hue.
    Args:
        img (PIL Image): PIL Image to be adjusted.
        hue_factor (float):  How much to shift the hue channel. Should be in
            [-0.5, 0.5]. 0.5 and -0.5 give complete reversal of hue channel in
            HSV space in positive and negative direction respectively.
            0 means no shift. Therefore, both -0.5 and 0.5 will give an image
            with complementary colors while 0 gives the original image.
    Returns:
        PIL Image: Hue adjusted image.
    &quot;&quot;&quot;
    if not(-0.5 &lt;= hue_factor &lt;= 0.5):
        raise ValueError('hue_factor is not in [-0.5, 0.5].'.format(hue_factor))

    if not _is_pil_image(img):
        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))

    input_mode = img.mode
    if input_mode in {'L', '1', 'I', 'F'}:
        return img

    h, s, v = img.convert('HSV').split()

    np_h = np.array(h, dtype=np.uint8)
    # uint8 addition take cares of rotation across boundaries
    with np.errstate(over='ignore'):
        np_h += np.uint8(hue_factor * 255)
    h = Image.fromarray(np_h, 'L')

    img = Image.merge('HSV', (h, s, v)).convert(input_mode)
    return img


def adjust_gamma(img, gamma, gain=1):
    &quot;&quot;&quot;Perform gamma correction on an image.
    Also known as Power Law Transform. Intensities in RGB mode are adjusted
    based on the following equation:
        I_out = 255 * gain * ((I_in / 255) ** gamma)
    See https://en.wikipedia.org/wiki/Gamma_correction for more details.
    Args:
        img (PIL Image): PIL Image to be adjusted.
        gamma (float): Non negative real number. gamma larger than 1 make the
            shadows darker, while gamma smaller than 1 make dark regions
            lighter.
        gain (float): The constant multiplier.
    &quot;&quot;&quot;
    if not _is_pil_image(img):
        raise TypeError('img should be PIL Image. Got {}'.format(type(img)))

    if gamma &lt; 0:
        raise ValueError('Gamma should be a non-negative real number')

    input_mode = img.mode
    img = img.convert('RGB')

    np_img = np.array(img, dtype=np.float32)
    np_img = 255 * gain * ((np_img / 255) ** gamma)
    np_img = np.uint8(np.clip(np_img, 0, 255))

    img = Image.fromarray(np_img, 'RGB').convert(input_mode)
    return img


class Compose(object):
    &quot;&quot;&quot;Composes several transforms together.
    Args:
        transforms (list of ``Transform`` objects): list of transforms to compose.
    Example:
        &gt;&gt;&gt; transforms.Compose([
        &gt;&gt;&gt;     transforms.CenterCrop(10),
        &gt;&gt;&gt;     transforms.ToTensor(),
        &gt;&gt;&gt; ])
    &quot;&quot;&quot;

    def __init__(self, transforms):
        self.transforms = transforms

    def __call__(self, img):
        for t in self.transforms:
            img = t(img)
        return img


class ToTensor(object):
    &quot;&quot;&quot;Convert a ``numpy.ndarray`` to tensor.
    Converts a numpy.ndarray (H x W x C) to a torch.FloatTensor of shape (C x H x W).
    &quot;&quot;&quot;

    def __call__(self, img):
        &quot;&quot;&quot;Convert a ``numpy.ndarray`` to tensor.
        Args:
            img (numpy.ndarray): Image to be converted to tensor.
        Returns:
            Tensor: Converted image.
        &quot;&quot;&quot;
        if not(_is_numpy_image(img)):
            raise TypeError('img should be ndarray. Got {}'.format(type(img)))

        if isinstance(img, np.ndarray):
            # handle numpy array
            if img.ndim == 3:
                img = torch.from_numpy(img.transpose((2, 0, 1)).copy())
            elif img.ndim == 2:
                img = torch.from_numpy(img.copy())
            else:
                raise RuntimeError('img should be ndarray with 2 or 3 dimensions. Got {}'.format(img.ndim))

            # backward compatibility
            # return img.float().div(255)
            return img.float()


class NormalizeNumpyArray(object):
    &quot;&quot;&quot;Normalize a ``numpy.ndarray`` with mean and standard deviation.
    Given mean: ``(M1,...,Mn)`` and std: ``(M1,..,Mn)`` for ``n`` channels, this transform
    will normalize each channel of the input ``numpy.ndarray`` i.e.
    ``input[channel] = (input[channel] - mean[channel]) / std[channel]``
    Args:
        mean (sequence): Sequence of means for each channel.
        std (sequence): Sequence of standard deviations for each channel.
    &quot;&quot;&quot;

    def __init__(self, mean, std):
        self.mean = mean
        self.std = std

    def __call__(self, img):
        &quot;&quot;&quot;
        Args:
            img (numpy.ndarray): Image of size (H, W, C) to be normalized.
        Returns:
            Tensor: Normalized image.
        &quot;&quot;&quot;
        if not(_is_numpy_image(img)):
            raise TypeError('img should be ndarray. Got {}'.format(type(img)))
        # TODO: make efficient
        print(img.shape)
        for i in range(3):
            img[:,:,i] = (img[:,:,i] - self.mean[i]) / self.std[i]
        return img


class NormalizeTensor(object):
    &quot;&quot;&quot;Normalize an tensor image with mean and standard deviation.
    Given mean: ``(M1,...,Mn)`` and std: ``(M1,..,Mn)`` for ``n`` channels, this transform
    will normalize each channel of the input ``torch.*Tensor`` i.e.
    ``input[channel] = (input[channel] - mean[channel]) / std[channel]``
    Args:
        mean (sequence): Sequence of means for each channel.
        std (sequence): Sequence of standard deviations for each channel.
    &quot;&quot;&quot;

    def __init__(self, mean, std):
        self.mean = mean
        self.std = std

    def __call__(self, tensor):
        &quot;&quot;&quot;
        Args:
            tensor (Tensor): Tensor image of size (C, H, W) to be normalized.
        Returns:
            Tensor: Normalized Tensor image.
        &quot;&quot;&quot;
        if not _is_tensor_image(tensor):
            raise TypeError('tensor is not a torch image.')
        # TODO: make efficient
        for t, m, s in zip(tensor, self.mean, self.std):
            t.sub_(m).div_(s)
        return tensor


class Rotate(object):
    &quot;&quot;&quot;Rotates the given ``numpy.ndarray``.
    Args:
        angle (float): The rotation angle in degrees.
    &quot;&quot;&quot;

    def __init__(self, angle):
        self.angle = angle

    def __call__(self, img):
        &quot;&quot;&quot;
        Args:
            img (numpy.ndarray (C x H x W)): Image to be rotated.
        Returns:
            img (numpy.ndarray (C x H x W)): Rotated image.
        &quot;&quot;&quot;

        # order=0 means nearest-neighbor type interpolation
        return itpl.rotate(img, self.angle, reshape=False, prefilter=False, order=0)


class Resize(object):
    &quot;&quot;&quot;Resize the the given ``numpy.ndarray`` to the given size.
    Args:
        size (sequence or int): Desired output size. If size is a sequence like
            (h, w), output size will be matched to this. If size is an int,
            smaller edge of the image will be matched to this number.
            i.e, if height &gt; width, then image will be rescaled to
            (size * height / width, size)
        interpolation (int, optional): Desired interpolation. Default is
            ``PIL.Image.BILINEAR``
    &quot;&quot;&quot;

    def __init__(self, size, interpolation='nearest'):
        assert isinstance(size, int) or isinstance(size, float) or \
               (isinstance(size, collections.Iterable) and len(size) == 2)
        self.size = size
        self.interpolation = interpolation

    def __call__(self, img):
        &quot;&quot;&quot;
        Args:
            img (PIL Image): Image to be scaled.
        Returns:
            PIL Image: Rescaled image.
        &quot;&quot;&quot;
        if img.ndim == 3:
            return misc.imresize(img, self.size, self.interpolation)
        elif img.ndim == 2:
            return misc.imresize(img, self.size, self.interpolation, 'F')
        else:
            RuntimeError('img should be ndarray with 2 or 3 dimensions. Got {}'.format(img.ndim))


class CenterCrop(object):
    &quot;&quot;&quot;Crops the given ``numpy.ndarray`` at the center.
    Args:
        size (sequence or int): Desired output size of the crop. If size is an
            int instead of sequence like (h, w), a square crop (size, size) is
            made.
    &quot;&quot;&quot;

    def __init__(self, size):
        if isinstance(size, numbers.Number):
            self.size = (int(size), int(size))
        else:
            self.size = size

    @staticmethod
    def get_params(img, output_size):
        &quot;&quot;&quot;Get parameters for ``crop`` for center crop.
        Args:
            img (numpy.ndarray (C x H x W)): Image to be cropped.
            output_size (tuple): Expected output size of the crop.
        Returns:
            tuple: params (i, j, h, w) to be passed to ``crop`` for center crop.
        &quot;&quot;&quot;
        h = img.shape[0]
        w = img.shape[1]
        th, tw = output_size
        i = int(round((h - th) / 2.))
        j = int(round((w - tw) / 2.))

        # # randomized cropping
        # i = np.random.randint(i-3, i+4)
        # j = np.random.randint(j-3, j+4)

        return i, j, th, tw

    def __call__(self, img):
        &quot;&quot;&quot;
        Args:
            img (numpy.ndarray (C x H x W)): Image to be cropped.
        Returns:
            img (numpy.ndarray (C x H x W)): Cropped image.
        &quot;&quot;&quot;
        i, j, h, w = self.get_params(img, self.size)

        &quot;&quot;&quot;
        i: Upper pixel coordinate.
        j: Left pixel coordinate.
        h: Height of the cropped image.
        w: Width of the cropped image.
        &quot;&quot;&quot;
        if not(_is_numpy_image(img)):
            raise TypeError('img should be ndarray. Got {}'.format(type(img)))
        if img.ndim == 3:
            return img[i:i+h, j:j+w, :]
        elif img.ndim == 2:
            return img[i:i + h, j:j + w]
        else:
            raise RuntimeError('img should be ndarray with 2 or 3 dimensions. Got {}'.format(img.ndim))


class Lambda(object):
    &quot;&quot;&quot;Apply a user-defined lambda as a transform.
    Args:
        lambd (function): Lambda/function to be used for transform.
    &quot;&quot;&quot;

    def __init__(self, lambd):
        assert isinstance(lambd, types.LambdaType)
        self.lambd = lambd

    def __call__(self, img):
        return self.lambd(img)


class HorizontalFlip(object):
    &quot;&quot;&quot;Horizontally flip the given ``numpy.ndarray``.
    Args:
        do_flip (boolean): whether or not do horizontal flip.
    &quot;&quot;&quot;

    def __init__(self, do_flip):
        self.do_flip = do_flip

    def __call__(self, img):
        &quot;&quot;&quot;
        Args:
            img (numpy.ndarray (C x H x W)): Image to be flipped.
        Returns:
            img (numpy.ndarray (C x H x W)): flipped image.
        &quot;&quot;&quot;
        if not(_is_numpy_image(img)):
            raise TypeError('img should be ndarray. Got {}'.format(type(img)))

        if self.do_flip:
            return np.fliplr(img)
        else:
            return img


class ColorJitter(object):
    &quot;&quot;&quot;Randomly change the brightness, contrast and saturation of an image.
    Args:
        brightness (float): How much to jitter brightness. brightness_factor
            is chosen uniformly from [max(0, 1 - brightness), 1 + brightness].
        contrast (float): How much to jitter contrast. contrast_factor
            is chosen uniformly from [max(0, 1 - contrast), 1 + contrast].
        saturation (float): How much to jitter saturation. saturation_factor
            is chosen uniformly from [max(0, 1 - saturation), 1 + saturation].
        hue(float): How much to jitter hue. hue_factor is chosen uniformly from
            [-hue, hue]. Should be &gt;=0 and &lt;= 0.5.
    &quot;&quot;&quot;
    def __init__(self, brightness=0, contrast=0, saturation=0, hue=0):
        self.brightness = brightness
        self.contrast = contrast
        self.saturation = saturation
        self.hue = hue

    @staticmethod
    def get_params(brightness, contrast, saturation, hue):
        &quot;&quot;&quot;Get a randomized transform to be applied on image.
        Arguments are same as that of __init__.
        Returns:
            Transform which randomly adjusts brightness, contrast and
            saturation in a random order.
        &quot;&quot;&quot;
        transforms = []
        if brightness &gt; 0:
            brightness_factor = np.random.uniform(max(0, 1 - brightness), 1 + brightness)
            transforms.append(Lambda(lambda img: adjust_brightness(img, brightness_factor)))

        if contrast &gt; 0:
            contrast_factor = np.random.uniform(max(0, 1 - contrast), 1 + contrast)
            transforms.append(Lambda(lambda img: adjust_contrast(img, contrast_factor)))

        if saturation &gt; 0:
            saturation_factor = np.random.uniform(max(0, 1 - saturation), 1 + saturation)
            transforms.append(Lambda(lambda img: adjust_saturation(img, saturation_factor)))

        if hue &gt; 0:
            hue_factor = np.random.uniform(-hue, hue)
            transforms.append(Lambda(lambda img: adjust_hue(img, hue_factor)))

        np.random.shuffle(transforms)
        transform = Compose(transforms)

        return transform

    def __call__(self, img):
        &quot;&quot;&quot;
        Args:
            img (numpy.ndarray (C x H x W)): Input image.
        Returns:
            img (numpy.ndarray (C x H x W)): Color jittered image.
        &quot;&quot;&quot;
        if not(_is_numpy_image(img)):
            raise TypeError('img should be ndarray. Got {}'.format(type(img)))

        pil = Image.fromarray(img)
        transform = self.get_params(self.brightness, self.contrast,
                                    self.saturation, self.hue)
        return np.array(transform(pil))


# Easier version of color jitter
def Colorjitter2(brightness=0, contrast=0, saturation=0):
    return torchvision.transforms.ColorJitter(
                brightness=brightness,
                contrast=contrast,
                saturation=saturation
            )


# Normalization using imagenet mean and variance
def normalization_imagenet(inputs):
    # Construct the normalization
    normalize = torchvision.transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])

    return normalize(inputs)

# Denormalization using imagenet mean and variance
def denormalization_imagenet(inputs):
    # Construct the denormalization
    mean_r = 0.485
    mean_g = 0.456
    mean_b = 0.406
    std_r = 0.229
    std_g = 0.224
    std_b = 0.225
    denormalize = torchvision.transforms.Normalize(mean=[-mean_r/std_r, -mean_g/std_g, -mean_b/std_b],
                                                   std=[1/std_r, 1/std_g, 1/std_b])
    return denormalize(inputs)


# Denormalize batch of tensors
def denormalization_batch(inputs):
    # Get the batch size
    batch_size = inputs.shape[0]
    tensor_list = []
    for i in range(batch_size):
        tensor_list.append(torch.unsqueeze(denormalization_imagenet(inputs[i, :, :, :]), dim=0))

    return torch.cat(tuple(tensor_list), dim=0)


class Crop(object):
    &quot;&quot;&quot;Crops the given PIL Image to a rectangular region based on a given
    4-tuple defining the left, upper pixel coordinated, hight and width size.
    Args:
        a tuple: (upper pixel coordinate, left pixel coordinate, hight, width)-tuple
    &quot;&quot;&quot;

    def __init__(self, i, j, h, w):
        &quot;&quot;&quot;
        i: Upper pixel coordinate.
        j: Left pixel coordinate.
        h: Height of the cropped image.
        w: Width of the cropped image.
        &quot;&quot;&quot;
        self.i = i
        self.j = j
        self.h = h
        self.w = w

    def __call__(self, img):
        &quot;&quot;&quot;
        Args:
            img (numpy.ndarray (C x H x W)): Image to be cropped.
        Returns:
            img (numpy.ndarray (C x H x W)): Cropped image.
        &quot;&quot;&quot;

        i, j, h, w = self.i, self.j, self.h, self.w

        if not(_is_numpy_image(img)):
            raise TypeError('img should be ndarray. Got {}'.format(type(img)))
        if img.ndim == 3:
            return img[i:i + h, j:j + w, :]
        elif img.ndim == 2:
            return img[i:i + h, j:j + w]
        else:
            raise RuntimeError(
                'img should be ndarray with 2 or 3 dimensions. Got {}'.format(img.ndim))

    def __repr__(self):
        return self.__class__.__name__ + '(i={0},j={1},h={2},w={3})'.format(
            self.i, self.j, self.h, self.w)
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../pytorch/" class="btn btn-neutral float-right" title="Pytorch">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../python/" class="btn btn-neutral" title="Python"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../python/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../pytorch/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../mathjaxhelper.js"></script>

</body>
</html>
