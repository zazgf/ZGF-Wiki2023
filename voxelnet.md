#### VoxelNet
To interface a highly sparse稀疏 LIDAR point cloud with a region proposal network(RPN区域建议网络),most existing efforts have focused on hand-crafted手工制作 feature representations特征表示，for example, a bird's eye view projectiong鸟瞰图.

In this work,we remove the need of manual feature engineering for 3D point clouds and purpose VoxelNet, a generic 3D detection network that unifies feature extraction and bounding box prediction into a single stage, end-to-end trainable deep network.

Specially,VoxelNet divides a point cloud into equally spaced 3D voxels and transforms a group of points within each voxel into a unified feature representation through the newly introduced voxel feature encoding(VFE) layer.In this way,the point cloud is encoded as a descriptive volumetric representation, which is then connected to a RPN to generate detections.

Our network learns an effective discriminative representation区分性表示 of objects with various geometrics, leading to encouraging results in 3D detection of pedestrains and cyclists, based on only Lidar.

![image](images/Screenshot%202021-01-11%2016:20:43.png)\
VoxelNet architecture. The feature learning network takes a raw point cloud as input, partitions the space into voxels, and transforms points within each voxel to a vector representation characterizing the shape information.The space is represented as a sparse 4D tensor.The convolutional middle layers processes the 4D tensor to aggregate spatial context 聚合空间语境.Finally,a RPN generates the 3D detection.

Scalling up 3D feature learning networks to orders of magnitude more points and to 3D detection tasks are the main challenges that we address in this paper.

We present VoxelNet, a generic 3D detection framework that simultaneously同时 learns a discriminative判别性 feature representation from point clouds and predicts accurate 3D bounding boxes, in an end-to-end fashion方式.

We design a novel新颖的 voxel feature encoding(VFE) layer,which enables inter-point interaction点间交互　within a voxel,by combining point-wise features逐点特征 with a locally aggregated feature聚合特征.

Stacking 堆叠 multiple VFE layers allows learning complex features for characterizing表征 local 3D shape information.

Specially, VoxelNet divides the point cloud into equally spaced 3D voxel等距的３Ｄ体素 ,encodes each voxel via stacked VFE layers, and then 3D convolution furture进一步 aggregate聚合 local voxel features, transforming the pointcloud into a high-dimensional volumetric体积 representation.

Finally,a RPN consumes the volumetric represetation and yields产生 the detection result.

This efficient algorithm benefits both from the sparse稀疏的 point structure and efficient parallel processing on the voxel grid体素网格的高效并行处理.

### VoxelNet Architecture
The proposed VoxelNet consists of three functional blocks:(1) Feature learning network,(2) Convolutional middle layers, and (3) Region proposal network

### Feature Learning Network
**Voxel Partition** Given a point cloud, we subdivide the 3D space into equally spaced voxels as shown in Figure 2.Suppose the point cloud encompasses包含 3D space with range D,H,W（点云尺寸） along the Z,Y,X axes respectively.We define each voxel of size vD,vH,and vW（体素尺寸） accordingly.The resulting所生成的 3D voxel grid is of size D'=D/vD, H'=H/vH, W'=W/vW（点云包含体素个数）.Here, for simplicity,we assume D,H,W are a multiple of vD,vH,vW.我们假设D,H,W是vD, vH, vW的倍数。

**Grouping** We group the points according to the voxel they reside in我们根据它们所在的体素对点进行分组.Due to factors such as distance,occlusion遮挡,object's relative pose物体的相对姿势,and non-uniform不均匀 sampling,the LiDAR point cloud is sparse and highly variable高度可变的 point density点密度 throughout the space.Therefore, after gouping, a voxel will contain a variable number of points.

**Random Sampling** Typically a high-definition LiDAR point cloud is composed of ~100k points. Directly processing all the points not only imposes加强 increased memory/efficiency burdens负担　on the computing platform, but also highly variable point density  throughout the space might bias the detection.To this end因此,we randomly sample a fixed number, T,of points from those voxels containing more than T points.This sampling strategy战略 has two purpose,(1)computational saving;and (2)decrease the imbalance of points between the voxels which reduces the sampling bias, and adds more variation变化 to training.

**Stacked Voxel Feature Encoding**\
![image](images/Screenshot%202021-01-12%2009:18:52.png)\
The key innovation革新 is the chain链 of VFE layers.For simplicity, Figure 2 illustrates the hierachical阶级式 feature encoding process for one voxel.Without loss of generality概要,(在不失一般性的前提下)we use VFE Layer-1 to describe the details in the following paragraph段落.Figure 3 shows the architecture for VFE Layer-1.\
Denote表示 ![image](images/Screenshot%202021-01-12%2010:02:35.png) as a non-empty voxel containing t≤Ｔ LiDAR points,where ![image](images/Screenshot%202021-01-12%2010:03:35.png) contains XYZ coordinates for the i-th point and ![image](images/Screenshot%202021-01-12%2010:04:35.png) is the received reflectance反射率.We first compute the local mean局部均值 as the centroid质心 of all the points in V, denoted as ![image](images/Screenshot%202021-01-12%2010:16:13.png).Then we augment增加 each point ![image](images/Screenshot%202021-01-12%2010:03:35.png) with the relative offset w.r.t. the centriod and obtain the input feature set ![image](images/Screenshot%202021-01-12%2010:48:19.png)![image](images/Screenshot%202021-01-12%2010:48:18.png), Next, each ![image](images/Screenshot%202021-01-12%2010:48:20.png) is transformed through the fully connected network(FCN) into a feature space,where we can aggregate汇总 information from the point features ![image](images/Screenshot%202021-01-12%2011:02:17.png) to ecode the shape of the surface contained within the voxel.The FCN is composed of a linear layer, a batch normalization(BN批量标准化) layer and a rectified纠正的 linear unit(ReLU) layer.After obtaining point-wise feature representations, we use element-wise MaxPooling across all ![image](images/Screenshot%202021-01-12%2011:02:27.png) associated to V to get the locally aggregated feature ![image](images/Screenshot%202021-01-12%2011:27:35.png) 
Finally, we augment each ![image](images/Screenshot%202021-01-12%2011:02:27.png) with ![image](images/Screenshot%202021-01-12%2011:27:45.png) to form the point-wise concatenated级联的 feature as ![image](images/Screenshot%202021-01-12%2011:32:52.png) Thus we obtain the output feature set ![image](images/Screenshot%202021-01-12%2011:32:53.png).All non-empty voxels are ecoded in the same way and they share the same set of parameters in FCN.

We use ![image](images/Screenshot%202021-01-12%2011:32:56.png) to represent the i-th VFE layer that transforms input features of dimension ![image](images/Screenshot%202021-01-12%2011:32:57.png) into output features of dimension ![image](images/Screenshot%202021-01-12%2011:32:58.png). The linear layer learns a matrix of size ![image](images/Screenshot%202021-01-12%2011:32:60.png), and the point-wise concatenation yields the output of dimension ![image](images/Screenshot%202021-01-12%2011:32:58.png).

Because the output feature combines both point-wise features and locally aggregated feature, stacking VFE layers encodes point interactions互动　within a voxel and enables the final feature representation to learn descriptive shape information. The voxel-wise feature is obtained by transforming the output of VFE-n into ![i](images/Screenshot%202021-01-12%2014:01:27.png) via FCN and applying element-wise Maxpool where C is the dimension of the voxel-wise feature, as shown in Figure2.

**Saparse Tensor Representation**稀疏张量表示　By processing only the non-empty voxels, we obtain a list of voxel features,each uniquely独特的 associated to the spatial空间 coordinates of a pictular non-empty voxel.The obtained list of voxel-wise features can be represented as a sparse 4D tensor, of size C x D' x H' x W' as shown in Figure2.Although the point cloud contains ~100k points, more than 90% of voxels typically are empty.Representing non-empty voxel features as a sparse tensor greatly reduce the memory usage and computation cost during backpropagation反向传播, and it is a critical step in our efficient implementation.

### Convolutional Middle Layers
We use ConvMD![i](images/Screenshot%202021-01-12%2014:01:28.png) to represent an M-dimensional  convolution operator where ![image](images/Screenshot%202021-01-12%2011:32:57.png) and ![image](images/Screenshot%202021-01-12%2011:32:58.png) are the number of input and output channels, k,s, and p are the M-dimensional vectors correspoinding to kernel size, stride size and padding填充 size respectively.When the size across the M-dimensions are the same, we use a scalar to represent the size e.g. k for k=(k,k,k).

Each convolutional middle layer applies 3D convolution,BN layer, and ReLU layer sequentially依次.The convolutional middle layers aggregate voxel-wise features within a progressively逐步 expanding扩大的 receptive接收 field，adding more context to the shape description.The detialed sizes of the filters in the convolutional middle layers are explained in Section 3.

### Region Proposal Network
![image](images/Screenshot%202021-01-12%2011:32:55.png)\
Recently, region proposal提案 networks have become an important building block of top-performing object detection frameworks. In this work,we make servel key modifications to the RPN architecture proposed in [34], and combine it with the feature learning network and convolutional middle layers to form an end-to-end trainable pipeline管道.

The input to our RPN is the feature map provided by the convolutional middle layers.The architecture of this network is illustrate in Figure 4.The network has three blocks of fully convolutional layers.The first layer of each block downsamples the feature map by half via a convolution with a stride size of 2,followed by a sequence of convolutions of stride 1(xq means q applications of the filter).After each convolution layer,BN and ReLU operations are applied.We then upsample the output of every block to a fixed size and concatanate to construct the high resolution feature map. Finally, this feature map is mapped to the desired learning targets:(1) a probability score map and (2) a regression map.ＲＰＮ的输入是卷积中间层提供的特征图。该网络的体系结构如图４所示。该网络具有三个完全卷基层的块。每个块的第一层通过步幅为２的卷积对特征图进行一半下采样，然后是步幅１的卷积序列（xq 表示滤波器的ｑ个应用）。在每个卷基层之后，BN 和ReLU 操作被应用。然后，我们将每个块的输出上采样到固定大小，并汇总以构建高分辨率特征图。最后，将此特征图映射到所需的学习目标：（１）概率分数图和（２）回归图。

### Loss Function 
Let ![image](images/Screenshot%202021-01-12%2015:39:61.png) be the set of ![image](images/Screenshot%202021-01-12%2015:39:63.png) positive anchors锚点 and ![image](images/Screenshot%202021-01-12%2015:39:64.png) be the set of ![image](images/Screenshot%202021-01-12%2015:39:65.png) negative anchors.
We parameterize a 3D ground truth box as ![image](images/Screenshot%202021-01-12%2015:39:55.png),where ![image](images/Screenshot%202021-01-12%2015:39:56.png) represent the center location,![image](images/Screenshot%202021-01-12%2015:39:57.png) are length ,width,height of the box, and ![image](images/Screenshot%202021-01-12%2015:39:60png.png) is the yaw rotation around Z-axis. To retrieve找回 the ground truth box from a matching positive anchorparameterized as ![image](images/Screenshot%202021-01-12%2015:39:74.png),we define the residual vector残差向量 ![image](images/Screenshot%202021-01-12%2015:39:84.png) containing the 7 regression targets corresponding to center location △x,△y,△z,three dimensions △l, △w, △h, and the rotation △Θ, which are computed as :\
![image](images/Screenshot%202021-01-12%2016:31:41.png)\
where ![image](images/Screenshot%202021-01-12%2016:31:42.png) is the diagonal对角线 of the base of the anchor box.Here, we aim to directly estimate the oriented定向的 3D box and normallize Δx and Δy homogeneously均匀的 with the diagonal对角线 ![image](images/Screenshot%202021-01-12%2016:31:44.png),We define the loss function as follows:\
![image](images/Screenshot%202021-01-12%2016:31:45.png)\
where ![image](images/Screenshot%202021-01-12%2016:31:46.png) and ![image](images/Screenshot%202021-01-12%2016:31:47.png) represent the softmax output for positive anchor ![image](images/Screenshot%202021-01-12%2016:31:48.png) and negative anchor ![image](images/Screenshot%202021-01-12%2016:31:49.png) respectively,while ![image](images/Screenshot%202021-01-12%2016:31:50.png) and ![image](images/Screenshot%202021-01-12%2015:39:84.png) are the regression回归 output and ground truth for positive anchor ![image](images/Screenshot%202021-01-12%2016:31:48.png).The first two terms are the normalized classification loss for ![image](images/Screenshot%202021-01-12%2015:39:61.png) and ![image](images/Screenshot%202021-01-12%2015:39:64.png), where the ![image](images/Screenshot%202021-01-13%2011:26:10png.png) stands for binary cross entropy loss二元交叉熵损失 and α，β are postive constants balancing the relative importance. The last term ![image](images/Screenshot%202021-01-13%2011:26:11.png) is the regression loss, where we use the SmoothL1 function.

### Efficient Implementation
Gpus are optimized优化 for processing dense稠密 tensor structures．The problem with working directly with the point cloud is that the points are sparsely distributed across sapce and each voxel has a variable number of points.We devised设计的 
a method that converts the point cloud into a dense tensor structure where stacked VFE operations can be processed in parallel across points and voxels.\
![image](images/Screenshot%202021-01-13%2011:43:06.png)\
The method is summarized in Figure 5. We initialize a KxTx7 dimensional tensor structure to store the voxel input feature where K is the maximum number of non-empty voxels, T is the maximum number of points per voxel, and 7 is the input encoding dimension for each point.The points are randomized随机的 before processing.For each point in pointcloud, we check if the corresponding voxel already exists. This lookup operation is done efficiently in O(1) using a hash table where the voxel coordinate is used as the hash key.If the voxel is already initialized we insert the point to voxel location if there are less than T points, otherwise the point is ignored.If the voxel is not initialized, we initialize a new voxel, store its coordinate in the voxel coordinate buffer, and insert the point to this voxel location.The voxel input feature and coordinate buffers can be constructed建 via a signle pass over the point list, therefore its complexity is O(n).体素输入特征和坐标缓冲区可以通过对点列表的一次遍历来构造，因此其复杂度为O（n）。To further improve the memory/compute efficiency it is possible to only store a limited number of voxels(K) and ignore points coming from voxels with few points.

After the voxel input buffer is constructed,the stacked VFE only involves涉及 point level and voxel level dense operations which can be computed on a GPU in parallel.Note that, after concatenation级联 operations in VFE, we reset the features corresponding to empty points to zero such that they do not affect the computed voxel features.Finally, using the stored coordinate buffer we reorganize改组 the computed sparse voxel-wise structures to the dense voxel grid.最后，使用存储的坐标缓冲区，我们将计算的稀疏体素结构重组为密集体素网格.The following convolutional middle layers and RPN operations work on a dense voxel grid which can be efficiently implemented on a GPU.

## Training Details
### Network Details
Our experimental setup实验设置 is based on the LiDAR specifications of the KITTI dataset.\
**Car Detection** For this task,we consider point clouds within the range of [-3,1]x[-40,40]x[0,70.4]meters along Z,Y,X axis respectively.Points taht are Points that are projected outside of image boundaries are removed.We choose a voxel size of ![image](images/Screenshot%202021-01-13%2014:36:22.png) meters,which leads to D'=10,H'=400,W'=352. We set T = 35 as the maximum number of randomly sampled points in each non-empty voxel.We use two VFE layers VFE-1(7,32) and VFE-2(32,128).The final FCN maps VFE-2 output to ![image](images/Screenshot%202021-01-13%2014:36:23.png).Thus our feature learning net generate a sparse tensor of shape 128x10x400x352.To aggregate voxel-wise features, we employ three convolution middle layers sequentially as Conv3D(128,64,3,(2,1,1),(1,1,1)),Conv3D(64,64,3,(1,1,1),(0,1,1)),and Conv3D(64,64,3,(2,1,1),(1,1,1)), which yields a 4D tensor of size 64x2x400x352.After reshaping, the input to RPN is a feature map of size 128x400x352,where the dimensions correspond to channel,height, and width of the 3D tensor.Figure 4 illustrates the detailed network architecture for this task.Unlike, we use only one anchor size,![i](images/Screenshot%202021-01-13%2014:52:18.png) meters, centered at集中于 ![i](images/Screenshot%202021-01-13%2014:52:19.png) meters with two rotations, 0 and 90 degrees.Our anchor matching criteria匹配标准 as follows: An anchor is considered as positive if it has the highest Intersection over Union(IoU) with a ground truth or its IoU with ground truth is above 0.6(in bird's eye view).An anchor is considered as negative if the IoU between it and all ground true boxes is less than 0.45. We treat anchors as don't care if they have 0.45≤IoU≤0.6 with any ground truth.We set α＝1.5 and β=1 in Eqn.2.

**Pedestrain and Cyclist Detection** The input range is [-3,1]x[-20,20]x[0,48] meters along Z,Y,X axis respectively.We use the same voxel size as for car detection,which yields D=10, H=200, W=240.We set T=45 in order to obtain more LiDAR points for better capturing shape information.The feature learning network and convolutional middle layers ate identical相同 to the networks used in car detection task.For the RPN, we make one modification to block 1 in Figure 4 by changing the stride size in the first 2D convolution from 2 to 1. This allows finer resolution in anchor matching, which is necessary for detecting pedestrains and cyclists.We use anchor size ![1](images/Screenshot%202021-01-13%2015:15:22.png) ![1](images/Screenshot%202021-01-13%2015:15:23.png) meters centered at ![1](images/Screenshot%202021-01-13%2015:15:24.png) with 0 and 90 degrees rotation for pedestrain detection and use anchor size ![1](images/Screenshot%202021-01-13%2015:15:21.png) meters centered at ![1](images/Screenshot%202021-01-13%2015:15:24.png) with 0 and 90 degrees rotation for cyclist detecction.The specific anchor matching criteria is as follows:We assign an anchor as positive if it has the highest IoU with a ground truth, or its IoU with ground truth is above 0.5. An anchor is considered as negative if its IoU with every ground truth is less than 0.35.For anchors having 0.35≤IoU≤0.5 with any ground truth,we treat them as don't care.

During training, we use stochastic随机 gradient descent(SGD) with learning rate 0.01 for the first 150 epochs and decrease the learning rate to 0.001 for the last 10 epochs.We use a batchsize of 16 point clouds.

### Data Augmentation 数据扩展
Ｗith less than 4000 training point clouds, training our network from scratch will inevitably 不可避免 suffer from overfitting. To reduce this issue, we introduce three different forms of data augmentation. The augmented training data are generated on-the-fly即时　without the need to be stored on disk.

Define set ![1](images/Screenshot%202021-01-13%2014:53:17.png) as the whole point cloud, consisting of N points.We parameterize a 3D bounding box ![1](images/Screenshot%202021-01-13%2014:54:17.png),where ![1](images/Screenshot%202021-01-13%2014:55:17.png) are center locations, l,w,h are length, width, height, and θ is the yaw rotation around Z-axis.We define ![1](images/Screenshot%202021-01-13%2014:56:17.png) ![1](images/Screenshot%202021-01-13%2014:57:17.png) as the set containing all LiDAR points within ![1](images/Screenshot%202021-01-13%2014:58:17.png), where p=[x,y,z,r] denotes a particular LiDAR point in the whole set M.

The first form of data augmentation applies perturbation摄动 independently to each ground truth 3D bounding box together with those LiDAR points within the box.Specifically,around Z-axis we rotate ![1](images/Screenshot%202021-01-13%2014:58:17.png) and the associated ![1](images/Screenshot%202021-01-13%2014:62:17.png) with respect to (![1](images/Screenshot%202021-01-13%2014:55:17.png)) by a uniformally统一的 distributed random variable ![1](images/Screenshot%202021-01-13%2014:82:17.png). Then we add a translation (Δx,Δy,Δz) to the XYZ components of ![1](images/Screenshot%202021-01-13%2014:58:17.png) and to each point in ![1](images/Screenshot%202021-01-13%2014:62:17.png),where Δx,Δy,Δz are drawn independently from a Gaussian distribution with mean zero and standard deviation 1.0. To avoid physically impossible outcomes, we perform a collision碰撞 test between any two boxes after the perturbation and revert还原 to orignal if a collision is detected.Since the perturbation is applied to each ground truth box and the associated LiDAR points independently, the network is able to learn from substantially实质上 more variations than from the orignal training data.

Secondly,we apply global scaling to all ground truth boxes ![1](images/Screenshot%202021-01-13%2014:58:17.png) and to whole point cloud M. Specifically, we multiply the XYZ coordinates and the three dimensions of each ![1](images/Screenshot%202021-01-13%2014:58:17.png), and the XYZ coordinates of all points in M with a random variable drawn from uniform distribution [0.95,1.05]. Introducing global scale augementation improves robustness of the network for detecting objects with various sizes and distances as shown in image-based classification and detection tasks.

Finally, we apply global rotation to all ground truth boxes ![1](images/Screenshot%202021-01-13%2014:58:17.png) and to the whole point cloud M. The rotation is applied along Z-axis and around(0,0,0). The global rotation offset is determined by sampling from uniform distribution [-π/4,π/4].By rotating the entire point cloud, we simulate the vehicle making a turn.





